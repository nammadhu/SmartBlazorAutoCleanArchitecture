fix cache issue & clearance ...client ok but not on server
okkk leave for now, will see later


add delete feature end to end


cardtype controller make only admin editable
add cardtype search with multiple parameters,
prefer on client side first then on server side

add cardtype,edit,delete calls with caching
town same all


i have below but giving error at    const tx = db.transaction(storeName, 'readonly');, as even previous line executing fine. looks like this error itself an issue,


M@dhusC0d$

page,


https://localhost:5001/manage-regions/countries/3dc5102c-9945-4e8d-9082-da1656c65f2e/atcs/44cfa7d8-91b9-431d-995b-fc0108a1e1b1/transaction-report

on shared project, 
on page will have IProductService 
on client render mode on wasm implementation with Indexeddb & api fetch, 
on server render mode on server,it will be Controller direct call service call & no cache

on page if customization required then ProductService which calls 
ProductIntermediateService,in which all customizations all and then api calls or whataever

update happening but response cache not modifying,had to do on server and client also mostly

lets make common shared service with ihttpclient,icachingservice

on wasm, make icachingservice as indexeddb



on shared project, service which uses IFetchData,ICache
on client render mode on wasm, it will be IApiFetch,IndexedDbService
on server render mode on server,it will be Controller service call & no cache
on 



since we are in blazor auto render, in which it runs sometimes on client-server and other time only on server mode. so each service from page will have to get data from service of interface of 2 types of implementations,
1> on client server mode, server side api HTTpReponse from controller endpoint & on page calls client service that makes httpclient call and responses will be stored on client cache storage using Indexeddb
2> on server render mode, page calls serice that makes direct service call to controller method instead of any http call.
now my previous full code should be modified like this,

To handle the dual-rendering modes (Blazor Server and Blazor WebAssembly), we can create a service abstraction using an interface with two implementations:

Client-Server Mode: Uses HttpClient to make API calls, caching responses using IndexedDB.

Server-Render Mode: Bypasses HttpClient and directly calls the server-side services.



seeding
show existing data on screen
client side rendering
add,edit,delete
cache,api call




Add Town
Add Card

Add Use Case

signalrhub correction
ui moves

takeout all domain from controller also


even for graphdb ,we should keep separate table or ?

iidentityrepo using graphdb, instead change it to use with default identity itself.


repeated packages removal at multiple projects





town => cards => like,comments
carousel,slider,card


Jio sim card on iphone 5G good range,on hotspot access cosmos db connectivity its throwing error,what is the reason or logic behind this ,someone please give some hint on this to understand.
Any other combination works fine like on same device airtel sim card 
or same jio sim on other samsung device all works fine.


i have iphone 12 indian version, it has one physical sim  card slot. but having an option to add esim, but if i add esim then is still i can use physical sim card slot for other sim card number or not?

using BlazorAuto.Web.Components;
using BlazorAuto.Web.Services;
using Microsoft.FluentUI.AspNetCore.Components;

builder.Services.AddFluentUIComponents();

add signalr
sync page
readme update

on press, sync working 
but had to reshow 

offline sync , polling
signalr 

readme update, 
on clientside, wrt each like product,card had to maintain which was the last sync time

add cancellation token for all palce wherever possible

rename client appdbcontext as ClientCacheDbContext

currently sync working only for client side if on server then gives error. so make on server it should not appear, on wasm automatically should sync on timely basis.
on navmenu hide on server mode also will be easy n quick

neeed to add background services features..
GetAllProducts change,currently its taking only paginated data


public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddNubeSyncServer(options =>
    {
        options.ConnectionString = Configuration.GetConnectionString("DefaultConnection");
    });
}


1 client caching
Sqlite with efcore and syncups

adding one more entity,component
signalr ,changes

video of how to make pdf from docx

  Unhandled exception rendering component: The input does not contain any JSON tokens. Expected the input to start with a valid JSON token, when isFinalBlock is true. Path: $ | LineNumber: 0 | BytePositionInLine: 0.
System.Text.Json.JsonException: The input does not contain any JSON tokens. Expected the input to start with a valid JSON token, when isFinalBlock is true. Path: $ | LineNumber: 0 | BytePositionInLine: 0.
 ---> System.Text.Json.JsonReaderException: The input does not contain any JSON tokens. Expected the input to start with a valid JSON token, when isFinalBlock is true. LineNumber: 0 | BytePositionInLine: 0.
   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes)
   at System.Text.Json.Utf8JsonReader.Read()
   at System.Text.Json.Serialization.JsonConverter`1[[CleanArchitecture.Application.Wrappers.PagedResponse`1[[CleanArchitecture.Domain.Products.DTOs.ProductDto, CleanArchitecture.Domain, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], CleanArchitecture.Application, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].ReadCore(Utf8JsonReader& reader, PagedResponse`1& value, JsonSerializerOptions options, ReadStack& state)
   --- End of inner exception stack trace ---
   at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack& state, JsonReaderException ex)
   at System.Text.Json.Serialization.JsonConverter`1[[CleanArchitecture.Application.Wrappers.PagedResponse`1[[CleanArchitecture.Domain.Products.DTOs.ProductDto, CleanArchitecture.Domain, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], CleanArchitecture.Application, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].ReadCore(Utf8JsonReader& reader, PagedResponse`1& value, JsonSerializerOptions options, ReadStack& state)
   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1[[CleanArchitecture.Application.Wrappers.PagedResponse`1[[CleanArchitecture.Domain.Products.DTOs.ProductDto, CleanArchitecture.Domain, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], CleanArchitecture.Application, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].ContinueDeserialize(ReadBufferState& bufferState, JsonReaderState& jsonReaderState, ReadStack& readStack, PagedResponse`1& value)
   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.<DeserializeAsync>d__1[[CleanArchitecture.Application.Wrappers.PagedResponse`1[[CleanArchitecture.Domain.Products.DTOs.ProductDto, CleanArchitecture.Domain, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], CleanArchitecture.Application, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].MoveNext()
   at System.Net.Http.Json.HttpContentJsonExtensions.<ReadFromJsonAsyncCore>d__12`1[[CleanArchitecture.Application.Wrappers.PagedResponse`1[[CleanArchitecture.Domain.Products.DTOs.ProductDto, CleanArchitecture.Domain, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], CleanArchitecture.Application, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].MoveNext()
   at BlazorAuto.Shared.Services.ProductServiceClient.GetPagedListProduct(GetPagedListProductQuery model) in C:\Users\MadhusudhanV\source\repos\Smart\Source\Src\Presentation\BlazorAuto\BlazorAuto.Shared\Services\ProductServiceClient.cs:line 40
   at BlazorAuto.Shared.Pages.Products.ProductList.OnInitializedAsync() in C:\Users\MadhusudhanV\source\repos\Smart\Source\Src\Presentation\BlazorAuto\BlazorAuto.Shared\Pages\Products\ProductList.razor:line 45
   at Microsoft.AspNetCore.Components.ComponentBase.RunInitAndSetParametersAsync()
   at Microsoft.AspNetCore.Components.RenderTree.Renderer.GetErrorHandledTask(Task taskToHandle, ComponentState owningComponentState)
   
   
   



controllerready
serviceclient
interface ready

service on client project,then server


Blazor and Clean Archi authentication integrated with login also completed,even google fine.
Do Some cleanup on Blazor for extra repeated code.

Display Products on screen on public,
for addition [authorize]
add caching for products to public
Ui Improvements
Loading icon change

Role management page
Owner,Products,Comments
Town,Profiles,Comments

Methodwise Dependency resolution

Use minimal endpoints for quicks


Am building SmartTown app using Blazor and Aspnet Core with below features, suggest me the right architecture.
Have Town data,each town has row of data ,less likely changing
With respect to each town, user,business owners can add their prefile called Cards. ANd can keep updating.
ANy other users can view ,like,comment.
Here all these things lively reflection necessary. 
Also need to have caching of data,offline serving mechanism.

Card Add,Update
Comment,Like

Live Reflection of these data 














google login added

connect the app with backend


then directly shift my codes
in same folder,rather separate...so easy to maintain










Connecting Blazor And Clean Architecture

add reference of api in blazor project

then making calls and using 



